Scoop
=====

Scoop is a query construction toolkit for scala. It is a very early experiment. You could say it is a strange mix between Squeryl and Anorm.
The main motivation is to provide a concise and practical solution that doesn't necessarily take complete control away from the SQL strings used. 

Lots of inspiration was taken from squeryl, anorm, and the apocalisp blog.

Installation
------------

TODO: Maven Repository

Model Definition
----------------

Since the main purpose is to construct queries, the model definition should pretty much mirror the database.

```scala
import com.gravitydev.scoop._

class Users (as: String) extends Table[Users]("users", Users) {
  val id          = col[Long]           ("id")
  val first_name  = col[String]         ("first_name")
  val last_name   = col[String]         ("last_name")
  val age         = col[Int]            ("age")
  val nickname    = col[String]         ("nickname")    nullable
}
def users = Users("u") // useful for creating default alias
```

Strong API
----------

*Not quite ready yet* The strong API is mostly modeled after squeryl (though nowhere near as featured at the moment).
It tries to provide the strongest guarantees that if your code compiles, the generated SQL is free of syntax (and some semantic) errors. 
Since you don't define the data model using classes representing rows, you have to do your own mapping though. In that sense, it is closer to ScalaQuery than Squeryl.
The syntax is also just a bit closer to SQL since you can use symbols like >, <=, etc even with primitives.

```scala
import com.gravitydev.scoop._, strong._

val query = from(users)(u => 
  where(u.age > 24 and u.name === "alvaro")
  select(u.first_name, u.last_name)
)
```

Query API (stringly typed)
--------------------------

*Somewhat usable* This API sacrifices some safety for flexibility and in some cases readability. It looks a bit more like SQL and you can 
actually combine the model objects with custom query strings.

The main differences compared with SQL:
 * You should define the aliases before hand so they are available throughout the query.
 * *select* is done last.

```scala
import com.gravitydev.scoop._, query._

val i = issues
val r = users as "reporter"
val a = users as "assignee"

val query = from(i)
  .innerJoin(r on i.reporter_id === r.id)
  .leftJoin(a on i.assigned_to === a.id)
  .where(r.accountId isNotNull)
  .orderBy(i.status desc, i.reason desc)
  .select(
    i.*, 
    r.first_name as "reporter", 
    a.first_name as "assignee", 
    "(SELECT COUNT(*) FROM stats WHERE stats.issue_id = " + i.id.sql + ") as total_stats"
  )
```

You can also make the alias for all columns generated by a table have a prefix:

```scala
val r = users as "reporter" prefix "reporter_"

val col = r.id          // will generate: "reporter.id as reporter_id"
val col = r.first_name  // will generate: "reporter.id as reporter_first_name"
```

Mapping and Parsers
-------------------

Parsers allow you to create a composable mapping from a ResultSet to your own object. Aliases are handled nicely. 
This is important if your query might be joining the same table twice or is using a different alias for a particular table.

```scala
case class Account (
  id: Long,
  name: String
)
object Account {
}

case class User (
  id: Long,
  name: String,
  account: Option[Account]
)

object Parsers {
  // make sure the case class has the correct number and type of parameters
  def account (a: Account) = a.id ~ a.name >> Account.apply
  def user (u: Users, a: Accounts) = u.id ~ u.first_name ~ u.last_name ~ opt(Accounts.parsers(a)) >> User.apply
}

// instantiate a parser by specifying the tables it should use
// the tables can be configured with aliases and/or column prefixes
// this makes the definition of the parser general, but the instantiation custom to the query
val userParser = Parsers.user( users, accounts )

val query = from(users)
  .leftJoin(accounts on employees.manager_id === managers.id)
  .select(userParser.columns:_*)
  .map(userParser)

val res: Seq[User] = query(con) 
```

